//THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src_ts/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src_ts/constants.ts
var DEFAULT_SETTINGS = {
  separator: "\n----\n"
};

// src_ts/commands.ts
var import_obsidian = require("obsidian");
var CommandManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.commands = this.getCommandsHash();
  }
  getCommandsHash() {
    return {
      "set-prompt": {
        name: "Set user prompt",
        hotkeys: [{ modifiers: ["Alt"], key: "S" }],
        callback: () => this.plugin.communicationManager.sendNoteCommand("set_prompt")
      },
      "write-scene-or-chat": {
        name: "Write Scene/Chat",
        hotkeys: [{ modifiers: ["Alt"], key: "W" }],
        callback: () => this.plugin.communicationManager.sendNoteCommand("write_scene_or_chat")
      },
      "custom-prompt": {
        name: "Custom Prompt",
        hotkeys: [{ modifiers: ["Alt"], key: "C" }],
        callback: () => this.plugin.communicationManager.sendNoteCommand("custom_prompt")
      },
      "remove-last-response": {
        name: "Remove Last Response",
        hotkeys: [{ modifiers: ["Alt"], key: "Z" }],
        callback: () => this.plugin.communicationManager.sendNoteCommand("remove_last_response")
      },
      "rewrite-part": {
        name: "Rewrite part",
        callback: () => this.plugin.communicationManager.sendNoteCommand("rewrite_part")
      },
      "rewrite-parts": {
        name: "Rewrite this and following parts",
        callback: () => this.plugin.communicationManager.sendNoteCommand("rewrite_parts")
      },
      "regenerate": {
        name: "Regenerate",
        callback: () => this.plugin.communicationManager.sendNoteCommand("regenerate")
      },
      "add-part": {
        name: "Add Part",
        callback: () => this.plugin.communicationManager.sendNoteCommand("add_part")
      },
      "update-summary": {
        name: "Update summary",
        callback: () => this.plugin.communicationManager.sendNoteCommand("update_summary")
      },
      "set-model-1": {
        name: "Set model 1",
        hotkeys: [{ modifiers: ["Alt"], key: "1" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("1")
      },
      "set-model-2": {
        name: "Set model 2",
        hotkeys: [{ modifiers: ["Alt"], key: "2" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("2")
      },
      "set-model-3": {
        name: "Set model 3",
        hotkeys: [{ modifiers: ["Alt"], key: "3" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("3")
      },
      "set-model-4": {
        name: "Set model 4",
        hotkeys: [{ modifiers: ["Alt"], key: "4" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("4")
      },
      "set-model-5": {
        name: "Set model 5",
        hotkeys: [{ modifiers: ["Alt"], key: "5" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("5")
      },
      "reset-model": {
        name: "Reset model",
        hotkeys: [{ modifiers: ["Alt"], key: "R" }],
        callback: async () => await this.plugin.utilityManager.setModelNumber("")
      },
      "rewrite-selection": {
        name: "Rewrite selection",
        callback: () => this.plugin.helperManager.rewriteSelection()
      },
      "translate": {
        name: "Translate selection",
        callback: () => this.plugin.helperManager.translateSelection()
      },
      "explain": {
        name: "Explain selected word",
        callback: () => this.plugin.helperManager.explainWord()
      },
      "switch-debug": {
        name: "Switch Debug Mode On/Off",
        callback: () => this.plugin.communicationManager.sendNoteCommand("switch_debug")
      },
      "interrupt-write": {
        name: "Interrupt Write",
        hotkeys: [{ modifiers: ["Alt"], key: "Q" }],
        callback: () => this.plugin.communicationManager.sendNoteCommand("interrupt_write")
      }
    };
  }
  registerAllCommands() {
    Object.entries(this.commands).forEach(([id, config]) => {
      this.registerCommand(id, config);
    });
  }
  registerCommand(id, config) {
    const commandConfig = {
      id,
      name: config.name,
      callback: () => {
        new import_obsidian.Notice(config.name);
        config.callback();
      }
    };
    if (config.hotkeys) {
      commandConfig.hotkeys = config.hotkeys;
    }
    this.plugin.addCommand(commandConfig);
  }
};

// src_ts/communication.ts
var net = __toESM(require("net"));
var CommunicationManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async getFinalMethodName(chatMode, methodName) {
    if (methodName === "write_scene_or_chat") {
      return chatMode ? "chat" : "write_scene";
    }
    if (methodName === "remove_last_response") {
      return chatMode ? "chat_remove_last_response" : "story_remove_last_response";
    }
    return methodName;
  }
  async sendNoteCommand(methodName, selected_text = "") {
    this.plugin.app.commands.executeCommandById("editor:save-file");
    const [absoluteFolderPath, absoluteFilePath] = this.plugin.utilityManager.getPaths();
    const partNumber = this.plugin.utilityManager.getPartNumber();
    const chatMode = await this.plugin.utilityManager.getMode();
    const finalMethodName = await this.getFinalMethodName(chatMode, methodName);
    const parameters = `${absoluteFolderPath},${absoluteFilePath},${finalMethodName},${chatMode},${partNumber},${selected_text}`;
    const response = await this.sendCommandToServer(parameters);
    return response;
  }
  async sendCommandToServer(command) {
    return new Promise((resolve, reject) => {
      const client = new net.Socket();
      let response = "";
      client.connect(9993, "localhost", () => {
        console.log("Connected to Python server");
        client.write(command);
      });
      client.on("data", (data) => {
        response += data.toString();
        client.destroy();
      });
      client.on("close", () => {
        console.log("Connection closed");
        resolve(response);
      });
      client.on("error", (err) => {
        console.error("Connection error: ", err);
        reject(err);
      });
    });
  }
};

// src_ts/utilities.ts
var import_obsidian2 = require("obsidian");
var path = __toESM(require("path"));
var UtilityManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getEditor() {
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    return view == null ? void 0 : view.editor;
  }
  async setStoryModelNumber(modelInt) {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("No active file");
      return;
    }
    const activeFileFolder = activeFile.parent;
    const settingsFilePath = (activeFileFolder == null ? void 0 : activeFileFolder.path) + "/Settings/Settings.md";
    const settingsFile = this.plugin.app.vault.getAbstractFileByPath(settingsFilePath);
    if (!settingsFile || settingsFile.extension !== "md") {
      new import_obsidian2.Notice("Settings file not found at ./Settings/Settings.md");
      return;
    }
    await this.plugin.app.fileManager.processFrontMatter(settingsFile, (frontmatter) => {
      frontmatter.model = modelInt;
    });
  }
  async setChatModelNumber(modelInt) {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("No active file");
      return;
    }
    await this.plugin.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
      frontmatter.model = modelInt;
    });
  }
  async setModelNumber(modelInt) {
    const chatMode = await this.getMode();
    if (chatMode) {
      await this.setChatModelNumber(modelInt);
    } else {
      await this.setStoryModelNumber(modelInt);
    }
  }
  async getMode() {
    const note = this.plugin.app.workspace.getActiveFile();
    if (!note)
      return false;
    const content = await this.plugin.app.vault.read(note);
    return /```\s*Custom instructions:/i.test(content);
  }
  getPartNumber() {
    const editor = this.getEditor();
    if (!editor)
      return 1;
    const cursor = editor.getCursor();
    const textBeforeCursor = editor.getRange({ line: 0, ch: 0 }, cursor);
    const escapedSeparator = this.plugin.settings.separator.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(escapedSeparator, "g");
    const matches = textBeforeCursor.match(regex);
    let count = matches ? matches.length : 0;
    count = count + 1;
    return count;
  }
  getPaths() {
    var _a;
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile) {
      console.log("No file is currently open");
      return ["", ""];
    }
    const vaultPath = this.plugin.app.vault.adapter.basePath;
    const folderPath = ((_a = activeFile.parent) == null ? void 0 : _a.path) || "";
    const absoluteFolderPath = path.join(vaultPath, folderPath);
    const absoluteFilePath = path.join(vaultPath, activeFile.path);
    return [absoluteFolderPath, absoluteFilePath];
  }
};

// src_ts/helpers.ts
var import_obsidian3 = require("obsidian");
var HelperManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async _processSelection(command) {
    const editor = this.plugin.utilityManager.getEditor();
    if (!editor) {
      new import_obsidian3.Notice("No active editor");
      return null;
    }
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian3.Notice("No selection found");
      return null;
    }
    const response = await this.plugin.communicationManager.sendNoteCommand(command, selection);
    if (!response) {
      new import_obsidian3.Notice("No response received");
      return null;
    }
    return response;
  }
  async rewriteSelection() {
    const response = await this._processSelection("rewrite_selection");
    if (!response)
      return;
    const editor = this.plugin.utilityManager.getEditor();
    if (!editor)
      return;
    if (editor.somethingSelected()) {
      editor.replaceSelection(response);
    } else {
      new import_obsidian3.Notice("No selection found");
    }
  }
  async translateSelection() {
    const response = await this._processSelection("translate");
    if (response) {
      new import_obsidian3.Notice(response);
    }
  }
  async explainWord() {
    const response = await this._processSelection("explain");
    if (response) {
      new import_obsidian3.Notice(response);
    }
  }
};

// src_ts/settings.ts
var import_obsidian4 = require("obsidian");
var MyPluginSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin Settings" });
    new import_obsidian4.Setting(containerEl).setName("Separator text").setDesc("Text pattern to match for counting parts").addText((text) => text.setPlaceholder("----").setValue(this.plugin.settings.separator).onChange(async (value) => {
      this.plugin.settings.separator = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src_ts/main.ts
var MyPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.commandManager = new CommandManager(this);
    this.communicationManager = new CommunicationManager(this);
    this.utilityManager = new UtilityManager(this);
    this.helperManager = new HelperManager(this);
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.commandManager.registerAllCommands();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
